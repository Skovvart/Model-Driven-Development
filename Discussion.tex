\section{Discussion}
Both behavior driven development and programming by contract are very useful approaches to software development, and merging them allows for even higher quality software as well as documentation.

There are however several improvements that could be made to our framework.
What is essential in our product is the ability to transform human readable text into contracts.
This process is currently somewhat cumbersome as our transformation language has very limited capabilities for matching strings, and this makes the transformations less reusable.
This ultimately requires more transformations to be written.
This problem could be solved in multiple ways: 

One option is allowing for better regular expressions matching as well as transformations on the matched expressions.
This could allow for more generalizable and reusable transformation rules.
Being able to transform the matched expressions could also potentially be used for automatic generation of parameter- and method names.
A matched substring could be transformed according to a name scheme such as camel-case or underscore separation and be used as the name for a parameter.

Another option is more tightly defining the language and relying less on user-provided transformations.
This does carry the risk of losing flexibility and is not a solution we believe is worth pursuing.

A more drastic and interesting alternative could be to use natural language processing \cite{jurafsky2002speech} to analyze the sentences and extract meaning automatically.
This could both be used for inferring method signatures as well as code contracts.
It would make it harder, if not impossible, to make any predictions about the quality of the generated contracts which is not desirable in many cases.
It would most likely also require a method of overriding wrongfully interpreted contracts when discovered.

Another problem is the lack of support for certain contracting features.
Our project does not, for example, support the concept of method-purity or other contracting features such as invariants or field constraints.
It would not be excessively hard to add some of the concepts such as method-purity and invariants, but not all programming-by-contract frameworks support some concepts such as field constraints.
It also lacks some syntactic sugar for allowing common contract features such as non-null constraints to be expressed effectively.

Conceptionally there are also some problems with merging software constraints and natural language.
While some concepts such as lists, stacks and integers can be expected to be known by people without computer science backgrounds, other concepts such as tuples might not, and expressing them can be hard.
Complex nested quantifier-contracts can also be troublesome to express in natural language, though they are not impossible.

Future work should solve the smaller issues such as lack of contracting features and make the framework less cumbersome to use.
It could also be very interesting to see the results of natural language processing with regards to contracts.