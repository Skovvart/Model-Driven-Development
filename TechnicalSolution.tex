%% Argument why each different DSL is advantageous
\subsection{Extending Gherkin to Support Contracted Software}
\label{sub:Extending Gherkin to Support Contracted Software}


The specification of informal behaviors in our framework is done using an
extended version of the Gherkin description language.
The extensions made allows the gradual conversion between classical step-oriented behaviors to generalized behaviors, such that they can later be translated to contracts.

%%% Removed BDD description, moved to Background //SÃ¸ren

\subsubsection{Generalizing Behaviors}
\label{sub:Generalizing Behaviors}

Our primary extensions to Gherkin are the addition of general
behavior clauses. A general behavior corresponds to a subroutine
and consists of a series of requirement blocks and insurance blocks
(see Listing~\ref{lst:featureexample}).

\begin{lstlisting}[caption={General Behavior Description of Adding Natural Numbers},label={lst:featureexample}]
  Feature: ...
  Behavior: Add two numbers
     Requiring <input_1> is a positive number
     And <input_2> is a positive number
     Ensuring the result is the sum of <input_1> and <input_2>
     And result is a positive number
\end{lstlisting}


These preconditions and postconditions are written completely in
natural language, and specifies informally which contracts the corresponding
behavior has.

\subsubsection{Keeping the Spirit of Behaviour Driven Development}
\label{ssub:Keeping the Spirit of Behaviour Driven Development}
By extending the Gherkin framework with only a few keywords, we have allowed the flexibility of using BDD with critical software
while still keeping the same type of expression as there normally is. In the end it is also possible to regenerate features with
the contract specific parts, and thus also allow reuse of existing tools.


\subsection{Transforming Behaviors to Contracts using Lettuce}
\label{sub:Transforming Behaviors to Contracts using Lettuce}


In order to translate high-level informal behaviors to low-level formal
contracts we have created a small DSL called Lettuce.
Lettuce allows direct translation of behaviors to methods,
and rule-wise pattern based translation for translating contract expressions.

\subsubsection{Mapping Behaviors}
\label{sub:Mapping Behaviors}

Behaviors from Gherkin are mapped to a method using a similarly named
construct in Lettuce. The construct needs a specification on which
description it matches from the feature definitions (see Listing~\ref{lst:featureexample}),
which structure it belongs to and how the actual method signature is
(see Listing~\ref{lst:behtransexample}).

\begin{lstlisting}[caption={General Behavior Description of Adding Natural Numbers},label={lst:behtransexample}]
  behavior 'Add two numbers'
    class Calculator
    signature 'public int add(int input1, int input2)'
  end
\end{lstlisting}

The actual translation process is rather simple,
each given behavior from the feature definition is mapped to the
specified class with the specified signature. Then each of its requirements
and insurances are mapped using the defined rules and attached to the mapped
method (see Section~\ref{sub:RewritingSentencestoLogicalExpressions}).

\subsubsection{Rewriting Sentences to Logical Expressions}
\label{sub:RewritingSentencestoLogicalExpressions}

In many ways, except for the semantic of usage,
preconditions and postconditions are similar in the way they are constructed.
As such we have made it possible for our transformation language to translate
to logical expression directly with the semantic of usage being determined by
the behavior descriptions. 
This allows the reuse of many of the transformations rules the user has written.


\begin{lstlisting}[caption={Different Types of Transformation Rules in Lettuce},label={lst:ruleexample}]
  rule positive $input is a positive number
    match greater_than $x=$input $y='0'
  end

  rule greater_than $x is greater than $y
    expr '$x > $y'
  end

  rule if_ 'if' $condition 'then' $texpr [(otherwise | 'else') $fexpr]
    if def? $fexpr then
      expr '$condition ==> $texpr && !$condition ==> $fexpr'
    else
      expr '$condition ==> $texpr'
    end
  end

  rule sum the $sum is the sum of $input1 and $input2
    expr '$sum == $input1 + $input2'
  end
\end{lstlisting}

A transformation rule has two main components: the pattern which a given
string should match and a body expression which defines how the
transformation should be done (see Listing~\ref{lst:ruleexample}).
To allow rules to reference each other, each rules must additionally be
given a unique identifier.

\paragraph{Patterns}
\label{par:Patterns}

To find the fitting transformation for a given string description
(written in either a requirement block or an insurance block), we allow the
definition of patterns which describes the appearance of the string.
A pattern is composed of a series of exact strings, or variables,
denoted by the sigil `\$', which represents a given word.
Furthermore to allow greater reusability we also allow alternation between
series of subpatterns (see Listing~\ref{lst:ruleexample}) surrounded by parentheses and
separated with a vertical bar `$\vert$' symbol, and we allow optional parts which are
surrounded with brackets.  This is similar to how regular regular
expressions work except Kleene-star `*' construction is not supported
resulting in that a subpattern can be matched at most once.

\paragraph{Transformation Expressions}
\label{par:Transformation Expressions}
While patterns specify which patterns are matched, transformation expressions
specify how to translate a given pattern to a formal logical expression.
In our language we support four kinds of transformation expressions:
generation, forwarding, conditional and failure (see Listing~\ref{lst:ruleexample}. for the first three).
Generation is written with the keyword `expr'
followed by the string which should be generated on output, where variables
in that string are replaced by the words captured in the pattern.
Forwarding permits a rule to refer to previously written rules that should further handle the
transformations and thus enhances reusability.
A forward expressions is written with the keyword `match',
followed by the name of the rule that should handle further transformations,
and in the end a series of assignments to the variables of the forwarded
rules patterns.
To handle variables which occur in alternation and optional parts of a
pattern, the transformation permits the usage of if def?-then-else expression.
These expressions allows checking if a series of variables exist,
and handle transformation flow accordingly.
In the end failures, which are denoted by the keyword `fail',
are useful as placeholders until an actual transformation is written.

\subsubsection{Evaluation of Transformation Rules}
\label{sub:Evaluation of Transformation Rules}

The process of evaluating a feature description using the transformation rules require two steps:
\begin{enumerate}
  \item Pattern-match the given string to find the rule to evaluate
  \item Executing the body of the rule with the captured variables
\end{enumerate}
To accommodate the first part of the process we translate each pattern to a
similar named regular expression. As an example take the pattern string of rule positive from Listing~\ref{lst:ruleexample}, it will be translated 
from \textit{\$input is a positive number} to \textit{\textbackslash s*+(?\textless input\textgreater\textbackslash S+)\textbackslash s* is a postive number}.

Then we try to match the string with each pattern until we succeed,
and then each variable in the pattern is captured into an environment
which maps variable names to values.
After a match is found, the second process is started where the body
for the matched pattern is evaluated given the captured environment of assigned variables.
The evaluation is dependent in which type of expression is specified
and is done as follows:

\begin{description}
  \item[Generation] The generation statements are evaluated simply
    by replacing all variables in the desired result expression with their 
    value in the environment. 
  \item[Forwarding] Transformations that use forwarding are evaluated by
    assigning each of the variables in the pattern with the values in the
    current environment and then further evaluating the forwarded rule.
  \item[Conditional] To evaluate a conditional expression, we check if all
    the variables specified exist in the current environment.
    If they exist the `then' inner transformation is evaluated recursively
    with the given variables, otherwise the `else' inner transformation
    is evaluated similarly.
  \item[Failure] We simply throw an exception with the given message
    if a failure statement is met.
\end{description}

\subsubsection{Transformations as an Opportunity of Reusing Expressions}
\label{ssub:TransformationsasanOppurtunityofReusingExpressions}
As a consequence of having the transformation language, Lettuce,
we allow programmers to generate templates from recurring behavior descriptions in a flexible way. This allows semi-automatising otherwise 
routinely tasks by leveraging model-driven development, and possibly saving developer time and effort spent while increasing safety over manual
translation.


\subsection{Tomato -- a JML-compatible Language for the Generalized Contracted Software Model}
\label{sub:Tomato-aJML-compatibleLanguagefortheGeneralizedContractedSoftwareModel}


To represent contracted software we have chosen to create a subset of the
Java Modelling Language called Tomato,
which focuses primarily on the interface-specific parts of Java.
Tomato is a specific DSL implementation of our general Programming-by-Contract output model, and thus has the same set of features
namely preconditions, postconditions and invariants.

\subsubsection{Representing Logical Expressions}
\label{sub:Representing Logical Expressions}
The base for the supported contracting features are logical expressions, that express
the success of a condition.
To allow the same type of expressiveness as in Java, we support all pure
logical expressions. This is expressions that do not have any side effects and can be judged as Boolean.
Furthermore, Tomato similarly to JML \cite{leavens2006design},
supports extensions that allow formulation of more complicated
expressions such as implications and quantifiers,
and those that specify change in the state of an object such as \textbackslash result
and \textbackslash old($\cdot$).

\begin{lstlisting}[language=Java,caption={Contracted Method for Adding Natural Numbers},label={lst:jmlexample}]
  class Calculator {
    //@ requires input_1 > 0
    //@ requires input_2 > 0
    //@ ensures \result == input_1 + input_2
    //@ ensures \result > 0
    public /*@ pure @*/ int add(int input_1, int input_2) { ... }
  }
\end{lstlisting}

\subsubsection{Preconditions and Postconditions}
\label{sub:Preconditions and Postconditions}

As the idea with code contracting is the specification of the behavior of
an object, Tomato allows specification of pre- and postconditions of methods.
Preconditions specify which prerequisites the caller of a method must
satisfy in order for the method to succeed and fulfil it's postcondition.
Preconditions in Tomato are declared using the \emph{`requires'}
keyword (see Listing~\ref{lst:jmlexample}).
Conversely, postconditions, specified by the keyword \emph{`ensures'},
specify which guarantees the callee of a method will give after an invocation.
This allows the caller to predict what the method does,
and ensures further use for subsequent preconditions.

\subsubsection{Providing a Balanced Solution for Contracted Software}
\label{ssub:ProvidingaBalancedSolutionforContractedSoftware}
Although Tomato does not support the full suite of constructs support by JML, it provides a clean and useful way for contracting software; and because of 
the simple model it is based on, further development of the language can easily be made to better reflect the capabilities of JML.
