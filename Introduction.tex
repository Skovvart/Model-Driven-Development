\section{Introduction} % By SÃ¸ren

Communication between programmers and managers can in many ways be cumbersome and it requires insight of the respective domains.
Behavior Driven Development (BDD) helps this communication by specifying a way in which user specifications can be written in a structured human-readable form of English, and then mapped directly to software tests.
This allows managers to ensure that the specification are written down correctly, and it allows programmers to automatically run tests to assert that the software follows the specifications. 

While testing ensures that software works in most cases, sometimes most cases is not good enough. This might be in the case of developing a driver for a 
space shuttle, where an error in the driver might cause a crash and end-up costing billions of dollars.
Programming by contract \cite{meyer1992} solves this problem by introducing formal methods into software development, 
and allow developers to formally specify the behaviour of loops, routines and objects.

The goal is to introduce programming by contract to the concept of BDD. This includes designing and implementing a BDD-based framework,
which we have named Salad, that allows specifying contracts in human readable language in addition to existing features that can be extracted to tests.
The framework is based on the Cucumber BDD-framework \cite{hellesoy2012}.
This includes extending the already existing feature description language in Cucumber with new constructs, 
and creating a domain specific language (DSL) that specifies the mapping between natural language and formal contracts.
The framework yields Java-files containing classes with methods that have contracts in the style specified by the Java Modeling Language (JML) \cite{leavens2006design}.

Although we are testing our solution on JML, we are aiming that our framework should output to a generalized contracted software model (see Section~\ref{sub:AGeneralizedModelforContractedSoftware}) requiring
only a specific syntax implementation for the target language. This would allow the extension of our framework in cases such as the aforementioned space shuttle,
where a real-time contracted programming language is required such as Eiffel with SCOOP\cite{eiffel2012scoop} or C/C++ with contracting extensions\cite{digitalmars2011contractprogramming}.

Our aim is to create a rule mapping language which is expressive enough to handle a study case, when evaluating the solution.
By comparing the level of expressiveness to existing contract implementations, 
we reflect on the feasibility of designing such a language as well as examine the possibility of using these extensions in the real world.

This paper is organized as follows.
In Overview we give a general overview of BDD and our Salad framework.
This includes the different DSLs and their location in the framework.
Next, in Technical Solution, we give a more deep discription of our DSLs.
In Evaluation we perform an experiment to assess and evaluate our solution and comment on the results.
After this, the experiment's threats to validity is discussed.
In Related Work we highlight pieces that have a relation to this paper.
Finally, the sections Discussion and Conclusion respectively discusses various aspects surrounding our solution and concludes on the findings of this paper.

% Helge: 1-2 sentences about our findings?

%\begin{itemize}
%\item General statement introducing the area; You can most likely start with the first paragraph from your project description and evolve it.
%\item Explanation of the specific problem and why do we care about the problem.
%\item Explanation of your solution, and how it improves on the work by others. Relation to related work can be very brief, given that you have a separate extensive section devoted to this.
%\item A hint on how the solution was evaluated and what was the outcome of this evaluation.
%\item A summary (a "map") of how the paper is organized.
%\end{itemize}
