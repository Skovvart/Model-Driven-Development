\section{Introduction} % By SÃ¸ren

Communication between programmers and managers can in many ways be cumbersome and requires insight of their respective domains.
Behavior Driven Development (BDD) supports communication by specifying a way in which user specifications can be written in a structured human-readable form of English, and then mapped directly to software tests.
This allow managers to ensure that the specification are written down correctly, and it allow programmers to run tests automatically to assert that the software follows the specifications. 

While testing ensures that software works in most cases, sometimes most cases is not good enough.
This might be in the case of developing firmware for a space shuttle, where an error in the driver might cause a crash and end-up costing billions of dollars.
Programming by contract \cite{meyer1992} solves this problem by introducing formal methods in software development, 
and allow developers to formally specify the behavior of loops, routines and objects.

The goal of this project is to introduce programming by contract to the concept of BDD.
This includes designing and implementing a BDD-based framework, Salad, that allows specifying contracts in human readable language that can be extracted to tests.
The framework is based on the Cucumber BDD-framework \cite{hellesoy2012} whose existing feature description language we will extend and create a domain specific language (DSL) to specify the mapping between natural language and formal contracts.
The framework outputs Java-files containing classes with contracted methods in Java Modeling Language (JML) \cite{leavens2006design}.

Although we are testing our solution on JML, we aim to make the framework able to support a generalized contracted software model (see Section~\ref{sub:AGeneralizedModelforContractedSoftware}) requiring
only a specific syntax implementation for the target language. This would allow extension of our framework in cases such as the aforementioned space shuttle,
where a real-time contracted programming language is required like Eiffel with SCOOP\cite{eiffel2012scoop} or C/C++ with contracting extensions\cite{digitalmars2011contractprogramming}.

Our aim is to create a rule-mapping language which is expressive enough to handle a case study, when evaluating the solution.
By comparing the level of expressiveness in the generated results to existing contracting frameworks like JML, 
we reflect on the feasibility of designing such a language as well as examine the possibility of using these extensions in the real world.

This paper is organized as follows.
In Section~\ref{sec:Background} we give a general overview of feature descriptions, BDD and the tools used in this project. 
In Section~\ref{sec:Solution} we explain our solution: The Salad framework.
This includes an overview of the different DSLs, their purpose in the framework, a deeper description of our DSLs and the model transformation.
In Section~\ref{sec:Evaluation} we perform an experiment to assess and evaluate our solution and comment on the results.
After this, the experiment's threats to validity are discussed.
In Section~\ref{sec:RelatedWork} we highlight some of the work that has been carried out within the same topic as ours.
Finally, Section~\ref{sec:Discussion} discusses various aspects of our solution and Section~\ref{sec:Conclusion} concludes the paper.

% Helge: 1-2 sentences about our findings?

%\begin{itemize}
%\item General statement introducing the area; You can most likely start with the first paragraph from your project description and evolve it.
%\item Explanation of the specific problem and why do we care about the problem.
%\item Explanation of your solution, and how it improves on the work by others. Relation to related work can be very brief, given that you have a separate extensive section devoted to this.
%\item A hint on how the solution was evaluated and what was the outcome of this evaluation.
%\item A summary (a "map") of how the paper is organized.
%\end{itemize}
